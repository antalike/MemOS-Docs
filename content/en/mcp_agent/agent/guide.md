---
title: User Guide
desc: Published plugin tools directly access the MemOS cloud service API, quickly adding long-term memory capabilities to your Agent, making conversations more considerate and continuous.
---

## Coze Platform Plugin Tools

### 1. Plugin Listing Information

The MemOS Cloud Service Interface Plugin is now available on the Coze Store! You can directly [visit the tool link](https://www.coze.cn/store/plugin/7569918012912893995?from=store_search_suggestion) to add the plugin and achieve zero-code integration.

### 2. Plugin Description

#### Plugin Functions

*   `search_memory`: This tool is used to query user memory data and can return snippets most relevant to the input. It supports real-time memory retrieval during user-AI conversations and can also perform global searches across the entire memory. It can be used to create user profiles or support personalized recommendations. Parameters such as conversation ID, user ID, and query text are required for queries, and the number of returned memory items can also be set.

*   `add_memory`: This tool allows batch importing of one or more messages into the MemOS memory storage database, facilitating retrieval in future conversations to support chat history management, user behavior tracking, and personalized interaction. Information such as conversation ID, message content, sender role, conversation time, and user ID must be specified when using it.

#### Interface Description

*   search_memory Interface

| Parameter Name | Parameter Type | Description | Required |
| --- | --- | --- | --- |
| memory_limit_number | string | Limits the number of returned memory items; defaults to 6 if not provided | No |
| memos_key | string | Authorization key for MemOS cloud service | Yes |
| memos_url | string | URL address of MemOS cloud service | Yes |
| query | string | User input | Yes |
| user_id | string | Unique identifier of the user associated with the memory being queried | Yes |

*   add_memory Interface

| Parameter Name | Parameter Type | Description | Required |
| --- | --- | --- | --- |
| conversation_id | string | Unique identifier for the conversation | Yes |
| memos_key | string | Authorization key for MemOS cloud service | Yes |
| memos_url | string | URL address of MemOS cloud service | Yes |
| messages | Array | Array of message objects | Yes |
| user_id | string | Unique identifier of the user associated with the memory being queried | Yes |

### 3. Agent Call Example

#### Agent Persona and Reply Logic Example

```
You are a Q&A robot. Every time, you read the user's memory and interests, and reply with very clear logic to gain the user's favor.

## Workflow Content
# 1. Access {search_memory} to retrieve data materials
    After each user input, first call the retrieval function in MemOS memory relationships -- the {search_memory} plugin, input information:
        Record the user's name as user_id. If it is the first visit, set user_id to a 16-character string randomly generated by UUID.
        Use the user's speech content as the query.
# 2. Process {search_memory} output content:
    Get the data content. If there is a memory_detail_list field, regardless of whether the memory_detail_list is empty, directly output the memory_detail_list in JSON format; if the returned message is not "ok", prompt "Plugin retrieval failed".
# 3. Answer the user's question based on the retrieved memory_detail_list
    Extract the memory_value field value of each item in memory_detail_list, concatenate all strings with "\n" as the context material for answering the user's question; the large model can answer the user's query based on the information provided by the context; if the context information is an empty string, the large model can directly answer the user's query.
    Then record the content answered by the large model into "answer".
# 4. Access {add_memory} to store data materials
    Call the add_memory function to store the user's question and the corresponding answer, input information:
        chat_time: Call {current_time} to get the current time, format the timestamp as "%I:%M %p on %d %B, %Y UTC".
        conversation_id: Record the current time point chat_time accurate to the minute, and use the time point string as conversation_id.
        user_id: Record the user's name as user_id.
        messages: Record the query input by the user and all answers obtained, respectively as the content of the role and the content of the assistant in messages. chat_time uses the chat_time value just obtained, organized as a message:
        [
            {"role": "user", "content": query, "chat_time": chat_time},
            {"role": "assistant", "content": answer, "chat_time": chat_time}
        ]
    Get the {add_memory} plugin feedback. If the success field in data is True, it is successful, *no need to inform the user*; if the returned field is not True, prompt the user that add_memory access failed.

## Requirements
Every time you access {search_memory} and {add_memory}, you need to pass two fixed parameters:
memos_url = "https://memos.memtensor.cn/api/openmem/v1"
memos_key = "Token mpg-XXXXXXXXXXXXXXXXXXXXXXXXXXX"

Your role is a wise and caring memory assistant named Xiaozhi.
If all plugins run smoothly, there is no need to prompt the user for success in the content answered by the large model.
Generate user_id with UUID only during the user's first conversation, and reuse this user_id in subsequent work.
```

[Agent Example Link](https://www.coze.cn/s/85NOIg062vQ)
![Agent Workflow]({{cdnUrl}}/img/coze_workflow_compressed.png)
